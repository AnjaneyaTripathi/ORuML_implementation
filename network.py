import pandas as pdimport numpy as npimport timedata = pd.read_csv('dataset.csv')nodes = [0, 3, 4, 5, 7, 19, 32, 33, 39, 43, 44]routes = ['Network A -> Network B -> Network E -> Network P',          'Network A -> Network E -> Network B -> Network P',          'Network A -> Network B -> Network P',          'Network A -> Network E -> Network P',          'Network A -> Network P']# populate nodes to respective networksdef populate_networks(nodes):    network_A = []    network_B = []    network_E = []    network_P = []    for i in range(len(nodes)):        if(data.iloc[nodes[i]]['network_class'] == 'NETWORK A'):            network_A.append(nodes[i])        elif(data.iloc[nodes[i]]['network_class'] == 'NETWORK B'):            network_B.append(nodes[i])        elif(data.iloc[nodes[i]]['network_class'] == 'NETWORK E'):            network_E.append(nodes[i])        else:            network_P.append(nodes[i])    return network_A, network_B, network_E, network_P# check if nodes belong to the same networkdef check_network(start, end):    if(data.iloc[start]['network_class'] == data.iloc[end]['network_class']):        print('Belong to same network class, transmission can be done without any issues!')        status = 1    else:        print('Source and destination belong to different networks, optimal routing needs to be determined!')        status = 0    return status# get the class of each nodedef get_class(nodes, node):    if(nodes['class'][node] == 'CLASS 1'):        class_no = 1    elif(nodes['class'][node] == 'CLASS 2'):        class_no = 2    elif(nodes['class'][node] == 'CLASS 3'):        class_no = 3    else:        class_no = 4    return class_no# find the best route to communicate with external nodes, returns cost and nodesdef optimal_class_route(net_1, net_2):    result = 100    for i in net_1:        for j in net_2:            cost = get_class(data, j) + get_class(data, i)            if(result > cost):                result = cost                out_1 = i                out_2 = j    return result, out_1, out_2network_A, network_B, network_E, network_P = populate_networks(nodes)path_ab, out_a, out_b = optimal_class_route(network_A, network_B)path_ae, out_a, out_e = optimal_class_route(network_A, network_E)path_ap, out_a, out_p = optimal_class_route(network_A, network_P)path_be, out_b, out_e = optimal_class_route(network_B, network_E)path_bp, out_b, out_p = optimal_class_route(network_B, network_P)path_ep, out_e, out_p = optimal_class_route(network_E, network_P)paths = [[path_ab, path_be, path_ep],         [path_ae, path_be, path_bp],         [path_ab, path_bp],         [path_ae, path_ep],         [path_ap]]path_nodes = [[out_a, out_b, out_e, out_p],              [out_a, out_e, out_b, out_p],              [out_a, out_b, out_p],              [out_a, out_e, out_p],              [out_a, out_p]]# identifies the cost of each path based on the class typesdef calc_path_scores(path_scores):    index = 0    for i in paths:        for j in i:            path_scores[index] = path_scores[index] + j        path_scores[index] = path_scores[index] / len(i)        index = index + 1    return path_scores    # trust factor to be updated after each transmissiondef update_trust_scores(trust_scores, success, path):    if(success):        trust_scores[path] += 1    else:        trust_scores[path] -= 1    return trust_scores   # identify the best path     def find_path(trust_scores, path_scores):    best = 100    result  = np.add(np.dot(trust_scores, -1), path_scores)    for i in range(len(result)):        if(best > result[i]):            best = result[i]            path_no = i    return best, path_nodef optimal_routing(starting_node, destination_node, is_successful, trust_scores, path_scores):    best_path = -1    is_same_net = check_network(starting_node, destination_node)    if(is_same_net):        print('The source and destination are a part of the same network, they can communicate with each other')    else:        best_score, best_path = find_path(trust_scores, path_scores)        trust_scores = update_trust_scores(trust_scores, is_successful, best_path)    return trust_scores, best_pathdef start_simulation():    starting_nodes = [3, 5, 19, 19, 5, 3, 19, 5]    destination_nodes = [5, 32, 33, 33, 32, 33, 44, 44]    successes = [1, 1, 0, 1, 0, 0, 0, 1]    path_scores = [0, 0, 0, 0, 0]    trust_scores = [0, 0, 0, 0, 0]    path_scores = calc_path_scores(path_scores)    for i in range(len(starting_nodes)):        print('Identifying optimal route using machine learning...')        time.sleep(1)        print('...calculating\n')        time.sleep(1)        trust_scores, best_path = optimal_routing(starting_nodes[i], destination_nodes[i], successes[i], trust_scores, path_scores)        if(data.iloc[starting_nodes[i]]['network_type'] == 'Bluetooth' and data.iloc[destination_nodes[i]]['network_type'] == 'Bluetooth'):            print('Transmission happens via Bluetooth connection')        elif(best_path != -1):            print('The best path is %s' %routes[best_path])            print('Corresponding Nodes from each network are: ', path_nodes[best_path])        print('\nStarting to transmit message from source node %d to destination node %d \n' %(starting_nodes[i], destination_nodes[i]))        time.sleep(1)        if(successes[i]):            print('The message was successfully transmitted, trust factor of the chosen path has been incrememnted!')        else:            print('The message transmission failed, trust factor of the chosen path has been decremented!')        time.sleep(1)        print('\n\n --- X --- X --- X --- X ---\n\n')    return trust_scores, path_scorestrust_scores, path_scores = start_simulation()